<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>The Curious Case of Lex</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="https://unpkg.com/tachyons/css/tachyons.min.css">
        <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
        <style>
            body {
                font-family: monospace;
                color: #333;
                background-color: #faf9f6;
            }
            a {
                color: #8B6914;
                text-decoration: underline;
                transition: all 0.3s ease;
            }
            a:hover {
                opacity: 0.7;
            }
            .content-box {
                max-width: 700px;
            }
            .last-updated {
                font-size: 0.8rem;
                color: #888;
                text-align: right;
                margin-top: 2rem;
            }
            pre {
                margin: 0;
                padding: 0;
            }
            code {
                font-size: 75%;
            }
            pre code {
                margin: 0;
                background-color: #f0eee9;
                border: 1px solid #ccc;
                display: block;
                padding: 5px;
            }
            table {
                border-collapse: collapse;
                margin: 1.5em auto;
                width: 100%;
            }
            th, td {
                padding: 0.5em;
                text-align: left;
                border-bottom: 1px solid #ccc;
            }
            th {
                border-bottom: 2px solid #333;
                font-weight: 600;
            }
            .caption {
                font-size: 0.9em;
                font-style: italic;
                text-align: center;
                margin-top: 0.5em;
                color: #666;
            }
            h2 {
                margin-top: 2em;
                margin-bottom: 0.5em;
            }
            h3 {
                margin-top: 1.5em;
                margin-bottom: 0.5em;
            }
            .table-wrapper {
                overflow-x: auto;
                margin: 1.5em 0;
                -webkit-overflow-scrolling: touch;
            }
            /* Responsive table styling */
            @media (max-width: 768px) {
                table {
                    font-size: 0.75em;
                }
                th, td {
                    padding: 0.35em 0.25em;
                }
            }
            @media (max-width: 480px) {
                table {
                    font-size: 0.65em;
                }
                th, td {
                    padding: 0.3em 0.2em;
                }
            }
        </style>
    </head>
    <body class="tl">
        <main class="pa4 center content-box mw7 lh-copy">
            <div class="mw6 ph1">
		    <p>I recently spent a couple of days trying to train a convolutional neural network (CNN) to rerank documents using ColBERT similarity matrices as images. It appeared to double ColBERT's performance on various splits of BRIGHT, a reasoning-intensive retrieval benchmark (see below).</p>

                <div class="table-wrapper">
                <table>
                    <thead>
                        <tr>
                            <th>Method (nDCG@10)</th>
                            <th>Economics</th>
                            <th>AoPS</th>
                            <th>LeetCode</th>
                            <th>Robotics</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>CNN-Sim (Ours)</td>
                            <td><b>0.248</b></td>
                            <td><b>0.492</b></td>
                            <td>0.270</td>
                            <td><b>0.281</b></td>
                        </tr>
                        <tr>
                            <td>ColBERTv2</td>
                            <td>0.128</td>
                            <td>0.234</td>
                            <td><b>0.310</b></td>
                            <td>0.134</td>
                        </tr>
                    </tbody>
                </table>
                </div>
                <p class="caption">Table 1: Reranking performance (nDCG@10) with BM25 top-100 candidates (with gold documents additionally infused) on the test sets. For most splits, the CNN led to a 2× increase in nDCG@10.</p>

		<p>Unfortunately, what initially seemed like a promising direction ended up being a dead end for reasons that, in hindsight, were obvious. The model learned spurious correlations and collapsed completely when tested on larger candidate sets. In this blog post, I'll detail my motivations for this direction, my implementation, and what went wrong.</p>

                <h3>Reasoning-Intensive Information Retrieval</h3>

                <p>Recent advances in information retrieval have shifted focus towards reasoning-intensive information retrieval (RiiR): queries that require intensive reasoning to retrieve the most pertinent documents from a large corpus. An example would be a medical query that requires extensive search through medical journals and reasoning beyond semantic matching to determine the proper diagnosis.</p>

                <p>Before I dive into how CNNs got mixed up in all of this, I'll first give a rough outline of how ColBERT, an older retrieval model, works. ColBERT is a <i>late interaction</i> model: it encodes queries and documents independently (like a dual encoder) but retains token-level embeddings rather than collapsing them into a single vector. The "late" refers to when query-document interaction occurs, after encoding, at scoring time, but at token granularity. Specifically, ColBERT builds a similarity matrix between query and document tokens, then derives a relevance score via MaxSim: the sum of maximum similarities for each query token across all document tokens.</p>

                <h4>The Problem Formulation</h4>

                <p>A natural question arises: do similarity matrices for query/gold-document pairings look different from their query/non-gold-document counterparts? More specifically, if we construct a similarity matrix and "highlight" the MaxSim at each row, do we see visual cues that allow us to differentiate between query/gold-doc, query/normal-doc, and query/bad-doc pairings? Here, I used BM25, a lexical method that is extremely cheap and fast, to initially rank the documents. I took the "normal doc" to be BM25's top-1 result and the "bad doc" to be one that falls outside the top 100. I tried this on a few queries, and you can see an example below:</p>

                <img src="colbert_viz_aops_q99.png" alt="ColBERT similarity matrices visualization" style="max-width: 100%; margin: 1.5em auto; display: block;">
                <p class="caption">Figure 1: A query from the Art of Problem Solving (AoPS) split of BRIGHT with similarity matrices for its gold document, normal document, and bad document.</p>

                <p>As you can see from Figure 1, there are some subtle cues. If we define <i>tokens used</i> as the number of document tokens that get "highlighted" (i.e., are the maximum of at least one row) and <i>max single usage</i> as how often the most frequently used token appears, then query/gold-document pairings tend to be higher on the former and lower on the latter compared to query/non-gold-document pairings. That is, there's less "column" domination: the similarity matrix for gold documents looks flat because many tokens contribute, while for non-gold documents there's more clear token dominance, visible as "spikes."</p>

		<p><b>Given these visual cues, I was curious whether a CNN could learn, from similarity matrices alone, to disambiguate between gold documents and non-gold documents for a given query.</b></p>

		<p>I'll note here, that the idea of treating text matching as image recognition isn't new. Pang, Lan, and colleagues explored this direction extensively in the mid-2010s. MatchPyramid (2016) applied CNNs to word-level interaction matrices, DeepRank (2017) added detection and aggregation stages to name a few. Results were mixed; the approach never decisively beat traditional methods. Dense retrievers and late interaction models like ColBERT largely superseded this line of work. I was curious whether revisiting the visual intuition with ColBERT's richer token-level representations might yield something, especially for reasoning-intensive queries where the patterns seemed visually distinct.</p>

                <h3>Building the Pipeline</h3>

		<p>The goal was to see if a lightweight CNN could serve as an efficient final reranking step, even with minimal training data. I focused on the four hardest splits of BRIGHT: LeetCode, AoPS, Economics, and Robotics, training a separate CNN for each using only 30% of queries (30–42 queries per split). During training, the CNN saw only BM25's top 100 documents plus the gold documents (since BM25 has poor recall for reasoning-intensive queries). At test time, I applied the same setup: retrieve BM25's top 100, inject gold documents, shuffle, and let the CNN rerank.</p>

		<h3> Training the CNN</h3>

                <p>The CNN treats ColBERT similarity matrices as 128×128 grayscale images, using a 4-layer architecture (32 → 64 → 128 → 256 channels) with batch normalization, followed by an MLP head. Specifically, ColBERT (frozen) produces a similarity matrix, which is resized to 128×128 and treated as a grayscale image. The CNN progressively increases channels (1 → 32 → 64 → 128 → 256) while halving spatial dimensions (128 → 64 → 32 → 16 → 8) via max pooling. The final 8×8×256 = 16,384 features are flattened and passed through an MLP (16384 → 256 → 128 → 1) to produce a single relevance score. Training used listwise cross-entropy loss over candidate documents, with learning rate 10<sup>-4</sup>, AdamW optimizer, and 15 epochs.</p>

                <h3>The Collapse</h3>

                <p>Given the amazing results from Figure 1, my immediate next step was to test a trained model on an expanded candidate set. I wanted to see how the CNN performed when given BM25's top 250, 500, 750, and 1000. This is with the same test queries, only candidate depth changes. As shown below, the system collapsed <i>immediately</i>. I then retrained the CNN models, this time sampling from BM25's top 1000 instead of the top 100. This minimized the collapse, but the results were still unimpressive. The k=1000 model was much more robust but lost the sharp edge at top-100. What was going on?</p>

                <div class="table-wrapper">
                <table>
                    <thead>
                        <tr>
                            <th>Method</th>
                            <th>100</th>
                            <th>250</th>
                            <th>500</th>
                            <th>750</th>
                            <th>1000</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>CNN-Sim (trained k=100)</td>
                            <td><b>0.248</b></td>
                            <td>0.10</td>
                            <td>0.04</td>
                            <td>0.02</td>
                            <td>0.02</td>
                        </tr>
                        <tr>
                            <td>CNN-Sim (trained k=1000)</td>
                            <td>0.165</td>
                            <td><b>0.114</b></td>
                            <td>0.093</td>
                            <td>0.088</td>
                            <td>0.086</td>
                        </tr>
                        <tr>
                            <td>ColBERTv2</td>
                            <td>0.128</td>
                            <td>0.108</td>
                            <td><b>0.099</b></td>
                            <td><b>0.095</b></td>
                            <td><b>0.095</b></td>
                        </tr>
                    </tbody>
                </table>
                </div>
                <p class="caption">Table 2: CNN performance on the Economics split across candidate set sizes. The k=100 model collapses catastrophically; the k=1000 model is more robust but loses its edge.</p>

                <div id="collapse-visualization" style="margin: 3em 0;">
                    <h3>Visualizing the Collapse</h3>
                    <p style="color: #666; margin-bottom: 1.5em; line-height: 1.6;">
                        CNN-Sim shows a 2× improvement over ColBERTv2 when reranking BM25's top-100...
                        but catastrophically fails when the candidate set expands. The model trained on k=100
                        learned spurious correlations that don't generalize and the same stands for the model when
			trained on k=1000.
                    </p>

                    <div style="background-color: white; border-radius: 8px; border: 1px solid #ccc; padding: 24px; margin-bottom: 24px;">
                        <canvas id="collapseChart" style="height: 400px; min-height: 250px;"></canvas>
                    </div>
                </div>

                <h3>CNN Reranks ColBERTv2's Ranking</h3>

                <p>I decided to change the pipeline: have ColBERT first rerank the documents given BM25's top 1000 (with gold documents infused), then have the CNN rerank ColBERT's rankings.</p>

                <p>Unfortunately, this proved unfruitful. The CNN models trained on k=100 didn't improve ColBERT's ranking. Initially, I believed recall might have been the issue, but using a stronger model as the intermediary, such as Qwen3-reranker-0.6B, didn't help either (Table 3).</p>

<div class="table-wrapper">
<table>
  <thead>
    <tr>
      <th>Base Model</th>
      <th>Method</th>
      <th>Econ</th>
      <th>AoPS</th>
      <th>LC</th>
      <th>Robotics</th>
    </tr>
  </thead>
  <tbody>
    <!-- ColBERTv2 block -->
    <tr>
      <td rowspan="3">ColBERTv2</td>
      <td>CNN-Sim (Ours)</td>
      <td>0.072</td>
      <td><b>0.185</b></td>
      <td>0.162</td>
      <td><b>0.091</b></td>
    </tr>
    <tr>
      <td>ColBERTv2</td>
      <td><b>0.095</b></td>
      <td>0.156</td>
      <td><b>0.283</b></td>
      <td>0.077</td>
    </tr>
    <tr>
      <td>Recall %</td>
      <td>38.1%</td>
      <td>41.4%</td>
      <td>48.4%</td>
      <td>33.9%</td>
    </tr>

    <!-- separator row (optional) -->
    <tr>
      <td colspan="6" style="height: 8px;"></td>
    </tr>

    <!-- Qwen block -->
    <tr>
      <td rowspan="3" style="border-top: 2px solid #eee;">Qwen3-Reranker-0.6B</td>
      <td>CNN-Sim (Ours)</td>
      <td>0.102</td>
      <td><b>0.232</b></td>
      <td>0.198</td>
      <td><b>0.181</b></td>
    </tr>
    <tr>
      <td>Qwen3-Reranker-0.6B</td>
      <td><b>0.156</b></td>
      <td>0.156</td>
      <td><b>0.372</b></td>
      <td>0.121</td>
    </tr>
    <tr>
      <td>Recall %</td>
      <td>56.9%</td>
      <td>42.9%</td>
      <td>78.6%</td>
      <td>54.4%</td>
    </tr>
  </tbody>
</table>
</div>

<p class="caption">
  Table 3: Pipeline results: CNN reranking the base model's top-100 (ColBERTv2 or Qwen3-Reranker-0.6B).
  Recall is the percentage of gold documents the base model ranked in its top 100.
</p>

                <h3>The Culprit: Distributional Shift</h3>

                <p>ColBERT's/Qwen's top-100 looks completely different from BM25's top-100 in terms of similarity matrix structure. ColBERT's/Qwen's "mistakes" are semantically plausible but wrong for reasoning—a totally different error pattern than BM25's lexical false positives. <b>Essentially, the goal was to train a CNN to find patterns that translate to relevance, but in reality it learned patterns that translate to high lexical matches.</b> High lexical matches in the top 100 correlate with irrelevance, but the injected gold documents, by virtue of not being in the top 100, don't have high lexical matches. When expanding to the top 1000, the bottom 900 also lack high lexical matches, so whatever signal the CNN learned collapses (gold and the bottom 900 become indistinguishable).</p>

                <p>The CNN learned: <i>"flat, uniform matrices → relevant."</i> High variance and sparsity predict <i>low</i> CNN scores. The model captured texture statistics, not semantic relevance. Within BM25's top-100, a distributional quirk exists: gold documents exhibit dense but structured similarity patterns, while BM25 negatives show sharp lexical spikes. The CNN found a texture shortcut separating these classes. However, at ranks outside the top 100, many documents have uniform similarity (vague semantic overlap) with low variance, exactly what the CNN learned to prefer.</p>

                <h4>The Fundamental Limitation.</h4>

                <p>This failure reveals a deeper issue. Similarity matrices capture <i>which</i> tokens align and <i>how many</i> align, but not <i>how they logically connect</i>. For reasoning-intensive retrieval, relevance depends on token interactions <i>within</i> the document which is structure that is invisible to the query-document similarity matrix. A gold document and a plausible-but-wrong document may have identical similarity matrices, both flat and distributed. The difference lies in the reasoning structure: how evidence chains together to answer the query. This structure exists <i>within</i> the document, in <i>how</i> its content interacts to answer the query but that isn't clear from a similarity matrix alone.</p>

                <h3>Conclusion</h3>

		<p>This was all pretty obvious in hindsight. I tried tweaking the pipeline by training a CNN on ColBERT's top-100 instead of BM25's top-100, but this didn't lead to any improvements compared to using ColBERT alone. This tracks with the observations above: the similarity matrix is not the right medium for understanding relevance (visually). It's hard to disambiguate gold documents from decent documents. Maybe there are other structures worth exploring?</p> 

		<p> I skipped giving implementation details for the sake of brevity, but if you have any ideas/questions or just want to chat about this stuff (or information retrieval generally), please feel free to email me!</p>

            </div>

            <p class="pt3">
                <a href="../index.html">&larr; Back to musings</a>
            </p>
        </main>

        <script>
            const ctx = document.getElementById('collapseChart');
            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [100, 250, 500, 750, 1000],
                    datasets: [
                        {
                            label: 'CNN (trained k=100)',
                            data: [0.248, 0.10, 0.04, 0.02, 0.02],
                            borderColor: '#c41e3a',
                            backgroundColor: '#c41e3a',
                            borderWidth: 3,
                            pointRadius: 5,
                            pointHoverRadius: 7,
                            tension: 0
                        },
                        {
                            label: 'CNN (trained k=1000)',
                            data: [0.165, 0.114, 0.093, 0.088, 0.086],
                            borderColor: '#8B6914',
                            backgroundColor: '#8B6914',
                            borderWidth: 2,
                            pointRadius: 4,
                            borderDash: [5, 5],
                            tension: 0
                        },
                        {
                            label: 'ColBERTv2',
                            data: [0.128, 0.11, 0.10, 0.10, 0.09],
                            borderColor: '#4a5568',
                            backgroundColor: '#4a5568',
                            borderWidth: 2,
                            pointRadius: 4,
                            tension: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                font: {
                                    family: 'monospace',
                                    size: 12
                                },
                                padding: 15,
                                usePointStyle: true
                            }
                        },
                        tooltip: {
                            backgroundColor: 'white',
                            titleColor: '#333',
                            bodyColor: '#666',
                            borderColor: '#ccc',
                            borderWidth: 1,
                            titleFont: {
                                family: 'monospace',
                                weight: 'bold'
                            },
                            bodyFont: {
                                family: 'monospace'
                            },
                            padding: 12,
                            displayColors: true,
                            callbacks: {
                                title: function(context) {
                                    return 'k = ' + context[0].label + ' candidates';
                                },
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y.toFixed(3);
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Candidate Set Size (k)',
                                font: {
                                    family: 'monospace',
                                    size: 12
                                }
                            },
                            ticks: {
                                font: {
                                    family: 'monospace'
                                }
                            },
                            grid: {
                                color: '#e0e0e0'
                            }
                        },
                        y: {
                            min: 0,
                            max: 0.28,
                            title: {
                                display: true,
                                text: 'nDCG@10',
                                font: {
                                    family: 'monospace',
                                    size: 12
                                }
                            },
                            ticks: {
                                font: {
                                    family: 'monospace'
                                },
                                callback: function(value) {
                                    return value.toFixed(2);
                                }
                            },
                            grid: {
                                color: '#e0e0e0'
                            }
                        }
                    }
                }
            });
        </script>
    </body>
</html>
